# 禁用libgcc红区

本文讨论了如何为不支持红区的内核构建 libgcc。 如果您不针对 x86-64，则不需要它，因为 i*86 没有这样的要求。

## 什么是红区

红色区域是 [x86_64 abi](https://wiki.osdev.org/System_V_ABI#x86-64) 中描述的一项功能。

> 它是一个 128 字节长的区域，位于堆栈指针的正下方。此区域可供编译器使用，无需通知应用程序/操作系统或任何正在运行的中断处理程序。  
对于用户应用程序，没有问题，因为中断和其他内核相关代码不会干扰用户堆栈。 然而，在你的内核中，事情可能会变得很糟糕，特别是如果你有嵌套的中断并且没有红区支持。 想象一下，在你的中断处理程序中运行，gcc 将一些数据放在红色区域内，发生嵌套中断并破坏红色区域，反之亦然。
要解决这个问题，可以通过将 -mno-red-zone 传递给 GCC 来禁用 red-zone。

```shell
x86_64-elf-gcc $CFLAGS -mno-red-zone ...
```

## 为什么要修改libgcc

如果你链接到 [libgcc](https://wiki.osdev.org/Libgcc)（你应该这样做），则有一个问题：libgcc 是在启用红色区域的情况下构建的。

因此，虽然你的内核工作正常，但 libgcc 中的方法可能会出意外。  
解决方案很简单 - 使用 -mno-red-zone 重建 libgcc。幸运的是，GCC 通过在其源代码树中提供 multilib 支持。

## 准备

按照构建 [GCC 交叉编译器](https://wiki.osdev.org/GCC_Cross-Compiler) 或 [01构建本地gcc编译器](../cqwrteur课程/01构建gcc本地编译器/main.md)时的说明提取并准备 GCC 源代码，**但暂时不要运行 configure** 。

创建并编辑配置文件
```shell
vim $TOOLCHAINS_BUILD/gcc/gcc/config/i386/t-x86_64-elf
```
写入以下内容
```shell
# Add libgcc multilib variant without red-zone requirement

MULTILIB_OPTIONS += mno-red-zone
MULTILIB_DIRNAMES += no-red-zone
```
gcc默认不使用此配置，打开 gcc/config.gcc 并搜索 case 块，如下所示：
```shell
 x86_64-*-elf*)
 	tm_file="${tm_file} i386/unix.h i386/att.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h"
 	;;
```
这是为 x86_64-elf 创建 [GCC Cross-Compiler](https://wiki.osdev.org/GCC_Cross-Compiler) 时使用的目标配置。 修改它以包含新的 multilib 配置：
```shell
 x86_64-*-elf*)
	tmake_file="${tmake_file} i386/t-x86_64-elf" # include the new multilib configuration
	tm_file="${tm_file} i386/unix.h i386/att.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h"
	;;
```

## 构建libgcc

运行 configure，然后像往常一样调用 all-target-libgcc 和 install-target-libgcc，GCC 将构建两个版本的 libgcc - 一个启用了红色区域，一个没有。 你可以通过检查已安装的 libgcc.a 档案来检查构建是否成功：
```shell
find $TOOLCHAINSPATH/x86_64-pc-linux-gnu/x86_64-elf/lib -name 'libgcc.a'
```
如果一切顺利，您应该会看到在 no-red-zone multilib 目录中安装了另一个 libgcc：
```shell
/home/nagisa/toolchains/x86_64-pc-linux-gnu/x86_64-elf/lib/gcc/x86_64-elf/15.0.0/no-red-zone/libgcc.a
/home/nagisa/toolchains/x86_64-pc-linux-gnu/x86_64-elf/lib/gcc/x86_64-elf/15.0.0/libgcc.a
```

## 针对正确的 multilib 版本进行链接

假设你正在使用 GCC 来链接你的内核，所需要做的就是确保在执行最后的链接器调用时 -mno-red-zone 在你的 LDFLAGS 中。

```shell
x86_64-elf-gcc $LDFLAGS -mno-red-zone -o kernel $SOURCES
```

如果你不确定要使用哪个 libgcc 版本，你可以通过将 -mno-red-zone 和 -print-libgcc-file-name 传递给 GCC 来检查：

```shell
x86_64-elf-gcc -mno-red-zone -print-libgcc-file-name # /home/nagisa/toolchains/x86_64-pc-linux-gnu/x86_64-elf/lib/gcc/x86_64-elf/15.0.0/no-red-zone/libgcc.a
```